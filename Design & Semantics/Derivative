#lang simply-scheme

(define d
  (λ (e)
    (cond ((number? e) 0)
	  ((equal? e 'x) 1)
	  (else
	   ;; We handle only BINARY ops here, and only + and *
	   (let ((op (car e)) (u (cadr e)) (v (caddr e)))
	     (cond ((equal? op '+)
		    (list '+ (d u) (d v)))
		   ((equal? op '*)
		    (list '+
			  (list '* u (d v))
			  (list '* (d u) v)))
		   (else (error))))))))

;;; Examples:

;; > (d '(* (+ x 1) (+ x -1)))
;; (+ (* (+ x 1) (+ 1 0)) (* (+ 1 0) (+ x -1)))

;; > (d '(* x (* x (* x (* x x)))))
;; (+
;;  (*
;;   x
;;   (+ (* x (+ (* x (+ (* x 1) (* 1 x))) (* 1 (* x x)))) (* 1 (* x (* x x)))))
;;  (* 1 (* x (* x (* x x)))))




(define d2
  (λ (e)
    (cond ((number? e) 0)
	  ((equal? e 'x) 1)
	  (else
	   ;; We handle only BINARY ops here, and only + and *
	   (let ((op (car e)) (u (cadr e)) (v (caddr e)))
             
	     (cond ((equal? op '+)
		    (list '+ (d u) (d v)))
                   
		   ((equal? op '*)
		    (list '+
			  (list '* u (d v))
			  (list '* (d u) v)))

                   ((equal? op '/)
                    (list '-
                          (list * u (d v))
                          (list *('/ (d u) v)u)))
                   
		   (else (error))))))))






(define d-op-table
  (list (list '+ (λ (u1 v1) (+ (d u1) (d v1))))
        (list '* (λ (u1 v1) (* (d u1) (d v1))))))
        

(define lookup
  (λ (op table)
    (if (equal? op (caar table))
	(cadar table)
	(lookup op (cdr table)))))

(define d1
  (λ (e)
    (cond ((number? e) 0)
          ((equal? e 'x) 1)
          (else
           (let ((op (car e)) (u (cadr e)) (v (caddr e)))
             (apply (lookup op d-op-table)
                    (map (λ (ee) (d1 ee v)) u v)))))))






  
  



